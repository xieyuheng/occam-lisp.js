---
title: the plan
date: 2025-07-28
---

什么是不必要的元素？

首先是关于类型系统，
必要的是一种描述数据结构的方式，
能够描述就能表达和记录我们对问题的理解，
我经常称之为建模。
不必要的是把这种对数据结构的描述当成类型，
在编译时做静态类型检查。

# define-data

比如，我们可以用谓词来灵活地描述数据结构，
用 `define-data` 语法来声明新的 data predicate
和相关的 data constructors：

```scheme
(define-data exp?
  (var-exp (name string?))
  (apply-exp (target exp?) (arg exp?))
  (lambda-exp (bound-name string?) (body exp?)))
```

经过上面的定义，我们会有：

```scheme
exp?        ;; data predicate
var-exp     ;; data constructor
apply-exp   ;; data constructor
lambda-exp  ;; data constructor
var-exp?    ;; data predicate
apply-exp?  ;; data predicate
lambda-exp? ;; data predicate
```

还可以利用 data constructor 中所声明的 data field name，
来自动定义 data getters：

```scheme
var-exp-name
apply-exp-target
apply-exp-arg
lambda-exp-bound-name
lambda-exp-body
```

可不可以直接通过加 `!` 后缀来命名 data setters 呢？
否则要加 `set-` 前缀就太啰嗦了。

```scheme
var-exp-name!
apply-exp-target!
apply-exp-arg!
lambda-exp-bound-name!
lambda-exp-body!
```

比如 my-list：

```scheme
(define-data (my-list? E)
  (nil)
  (li (head E) (tail (my-list? E))))
```

会生成的 name 有：

```scheme
my-list?
nil
li
nil?
li?
li-head
li-tail
```

注意，类似 generic type 的定义，
generic predicate 需要给出 generic 参数（也是 predicate）：

```scheme
(assert (my-list? int? (li 1 (li 2 (li 3 (nil))))))
```

但是 data constructor 所生成的 predicate 不需要带有 generic 参数：

```scheme
(assert (li? (li 1 (li 2 (li 3 (nil))))))
```

这种谓词是很容易实现的，
因为不同的 data constructor 所构造出来的 data 都不一样，
可以通过其 constructor 来区分。
constructor 之间通过 module + name 就可以区分。

声明 data constructor 时，
除了 positional data field，
还应该支持 attributes。

比如这是另外一种定义 my-list 的方式：

```scheme
(define-data (my-list? E)
  (nil)
  (li :head E :tail (my-list? E)))
```
会生成的 name 有：

```scheme
my-list?
nil
li
nil?
li?
```

data getters 可以被 generic data getter 语法取代：

```scheme
(assert (equal? (:head (li 1 (nil))) 1))
```

就是 overload 函数作用语法到 `:key` 上。

# predicate combinators

我们还是可以保留 x-data 所定义的基础数据。
并且可以把 lattice-lisp 中的 type constructors
和 type operators 当作 predicate combinator：

```scheme
(assert ((tau int? int? :x int? :y int?) [1 2 :x 1 :y 2]))
```

由于是动态类型系统，不同考虑类型之间的子类型关系和等价关系，
所以可以直接用最简单的方式实现 `union` 和 `inter`，
这有些类似 schema system，比如 json 的各种 schema。

# function predicate

在类型系统中的函数类型 `(-> A B)`，
没法被实现为谓词，但是可以作为一种 debug 机制：

```scheme
(claim square (-> int? int?))
(define square (lambda (x) (mul x x)))
```

在 `meta-lisp run <file>` 时忽略这些 `claim`，
在 `meta-lisp debug <file>` 时把这些 `claim`
所声明的参数谓词作用于函数的参数，
把返回谓词作用于函数的返回值。

在此之外我们当然也可以有 `function?` 谓词。

把一个 arrow 作用于函数，
可以理解为获得了一个带有 assertion 的函数：

```scheme
((-> int? int?)
 (lambda (x) (mul x x)))

(define square
  ((-> int? int?)
   (lambda (x) (mul x x))))
```
